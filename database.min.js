"use strict";function Database(dbName){"undefined"!=typeof window&&"object"==typeof window&&(window.indexedDB||(window.indexedDB=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB),window.IDBTransaction||(window.IDBTransaction=window.IDBTransaction||window.webkitIDBTransaction||window.msIDBTransaction||{READ_WRITE:"readwrite"}),window.IDBKeyRange||(window.IDBKeyRange=window.IDBKeyRange||window.webkitIDBKeyRange||window.msIDBKeyRange)),dbName=dbName||"test";let db,onEvent;const eventHandler=e=>{onEvent&&"function"==typeof onEvent&&onEvent(e)},close=async()=>(db&&(db.close(),db=null),!0),open=async()=>new Promise((resolve,reject)=>{if(db)return resolve(db);let open=indexedDB.open(dbName,1);open.onerror=e=>{reject({code:400,message:err.message||err.toString()||"Error!"})},open.onupgradeneeded=e=>{db=e.target.result;db.createObjectStore(dbName,{keyPath:"key"})},open.onsuccess=e=>{db=e.target.result,resolve(db)}});const list=query=>new Promise(async(resolve,reject)=>{db||await open();let store=db.transaction([dbName],"readonly").objectStore(dbName),results=[];var gt=(query=!query||"object"!=typeof query?{}:query).gt||"\0",lt=query.lt||"ï¿¿";let limit;query.limit&&(limit=parseInt(query.limit));let reverse="next";query.reverse&&(reverse="prev");let req=store.openCursor(IDBKeyRange.bound(gt,lt,!0,!0),reverse);req.onsuccess=()=>{let cursor=req.result;if(!limit&&cursor||results.length<limit&&cursor){let result={};result=query.values?{key:cursor.value.key,value:cursor.value.value}:cursor.key,results.push(result),cursor.continue()}else resolve(results)},req.onerror=req.onblocked=err=>{reject({code:400,message:"Error deleting database. "+err.toString()})}});return{put:(key,value)=>new Promise(async(resolve,reject)=>{db||await open();let store=db.transaction([dbName],"readwrite").objectStore(dbName),req=store.put({value:value,key:key});req.onsuccess=()=>{var e={db:dbName,event:"write",key:key,timestamp:Date.now()};eventHandler(e),resolve(e)},req.onerror=req.onblocked=err=>{reject({code:400,message:err.message||err.toString()||"Error!"})}}),get:key=>new Promise(async(resolve,reject)=>{db||await open();let store=db.transaction([dbName],"readonly").objectStore(dbName),req=store.get(key);req.onsuccess=e=>{var result=req.result;let value=null;result&&result.value&&(value=result.value),resolve({key:key,value:value})},req.onerror=req.onblocked=err=>{reject({code:400,message:err.message||err.toString()||"Error!"})}}),del:(keys=[])=>new Promise(async(resolve,reject)=>{db||await open();let store=db.transaction([dbName],"readwrite").objectStore(dbName),keyPaths=[];if(!keys)return reject({code:400,message:"A key or an array of keys is required."});keyPaths="string"==typeof keys?[keys]:keys;let ops=[];keyPaths.forEach(path=>{ops.push({type:"del",key:path})});for(let i=0;i<keyPaths.length;i++)store.delete(keyPaths[i]);store.transaction.oncomplete=()=>{var e={db:dbName,event:"delete",keys:keyPaths,timestamp:Date.now()};eventHandler(e),resolve(e)},store.transaction.onerror=err=>{reject({code:400,message:err.message||err.toString()||"Error!"})}}),list:list,deleteDB:()=>new Promise(async(resolve,reject)=>{await close();let req=indexedDB.deleteDatabase(dbName);req.onsuccess=function(){var e={db:dbName,event:"deleteDB",timestamp:Date.now()};eventHandler(e),resolve(e)},req.onerror=req.onblocked=e=>{reject({code:400,message:"Error deleting database. "+e.toString()})}}),exportDB:async()=>{return await list({values:!0})},importDB:(items=[])=>new Promise(async(resolve,reject)=>{db||await open();let store=db.transaction([dbName],"readwrite").objectStore(dbName);store.transaction.oncomplete=()=>{var e={db:dbName,event:"importDB",keys:items.map(val=>val.key),timestamp:Date.now()};eventHandler(e),resolve(e)},store.onerror=err=>{reject({code:400,message:"Error importing database. "+err.toString()})};for(let x=0;x<items.length;x++)await store.put({key:items[x].key,value:items[x].value})}),onEvent:cb=>{onEvent=cb},close:close}}