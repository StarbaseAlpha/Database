"use strict";function Database(dbName){let db,onEvent;window.indexedDB||(window.indexedDB=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB),window.IDBTransaction||(window.IDBTransaction=window.IDBTransaction||window.webkitIDBTransaction||window.msIDBTransaction||{READ_WRITE:"readwrite"}),window.IDBKeyRange||(window.IDBKeyRange=window.IDBKeyRange||window.webkitIDBKeyRange||window.msIDBKeyRange),dbName||(dbName="test");const eventHandler=e=>{onEvent&&"function"==typeof onEvent&&onEvent(e)},close=async()=>(db&&(db.close(),db=null),!0),open=async()=>new Promise((resolve,reject)=>{if(db)return resolve(db);let open=indexedDB.open(dbName,1);open.onerror=(e=>{reject({code:400,message:err.message||err.toString()||"Error!"})}),open.onupgradeneeded=(e=>{(db=e.target.result).createObjectStore(dbName,{keyPath:"key"})}),open.onsuccess=(e=>{db=e.target.result,resolve(db)})}),list=query=>new Promise(async(resolve,reject)=>{db||await open();let store=db.transaction([dbName],"readonly").objectStore(dbName);query&&"object"==typeof query||(query={});let limit,results=[],gt=query.gt||"\0",lt=query.lt||"ï¿¿";query.limit&&(limit=parseInt(query.limit));let reverse="next";query.reverse&&(reverse="prev");let req=store.openCursor(IDBKeyRange.bound(gt,lt,!0,!0),reverse);req.onsuccess=(()=>{let cursor=req.result;if(!limit&&cursor||results.length<limit&&cursor){let result={};result=query.values?{key:cursor.value.key,value:cursor.value.value}:cursor.key,results.push(result),cursor.continue()}else resolve(results)}),req.onerror=req.onblocked=(err=>{reject({code:400,message:"Error deleting database. "+err.toString()})})});return{put:(key,value)=>new Promise(async(resolve,reject)=>{db||await open();let req=db.transaction([dbName],"readwrite").objectStore(dbName).put({value:value,key:key});req.onsuccess=(()=>{let e={db:dbName,event:"write",key:key,timestamp:Date.now()};eventHandler(e),resolve(e)}),req.onerror=req.onblocked=(err=>{reject({code:400,message:err.message||err.toString()||"Error!"})})}),get:key=>new Promise(async(resolve,reject)=>{db||await open();let req=db.transaction([dbName],"readonly").objectStore(dbName).get(key);req.onsuccess=(e=>{resolve({key:req.result.key,value:req.result.value})}),req.onerror=req.onblocked=(err=>{reject({code:400,message:err.message||err.toString()||"Error!"})})}),del:(keys=[])=>new Promise(async(resolve,reject)=>{db||await open();let store=db.transaction([dbName],"readwrite").objectStore(dbName),keyPaths=[];if(!keys)return reject({code:400,message:"A key or an array of keys is required."});let ops=[];(keyPaths="string"==typeof keys?[keys]:keys).forEach(path=>{ops.push({type:"del",key:path})});for(let i=0;i<keyPaths.length;i++)store.delete(keyPaths[i]);store.transaction.oncomplete=(()=>{let e={db:dbName,event:"delete",keys:keyPaths,timestamp:Date.now()};eventHandler(e),resolve(e)}),store.transaction.onerror=(err=>{reject({code:400,message:err.message||err.toString()||"Error!"})})}),list:list,deleteDB:()=>new Promise(async(resolve,reject)=>{await close();let req=indexedDB.deleteDatabase(dbName);req.onsuccess=function(){let e={db:dbName,event:"deleteDB",timestamp:Date.now()};eventHandler(e),resolve(e)},req.onerror=req.onblocked=(e=>{reject({code:400,message:"Error deleting database. "+e.toString()})})}),exportDB:async()=>{return await list({values:!0})},importDB:(items=[])=>new Promise(async(resolve,reject)=>{db||await open();let store=db.transaction([dbName],"readwrite").objectStore(dbName);store.transaction.oncomplete=(()=>{let e={db:dbName,event:"importDB",keys:items.map(val=>val.key),timestamp:Date.now()};eventHandler(e),resolve(e)}),store.onerror=(err=>{reject({code:400,message:"Error importing database. "+err.toString()})});for(let x=0;x<items.length;x++)await store.put({key:items[x].key,value:items[x].value})}),onEvent:cb=>{onEvent=cb},close:close}}