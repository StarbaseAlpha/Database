"use strict";function Database(dbName){let db,onEvent;dbName||(dbName="test");const eventHandler=e=>{onEvent&&"function"==typeof onEvent&&onEvent(e)},Fail=(err,reject)=>{reject({code:400,message:err.message||err.toString()||"Error!"})},close=async()=>new Promise((resolve,reject)=>{db?(db.close(),db=null,resolve(!0)):resolve(!0)}),txStore=async(method,fail)=>{db||await(async()=>new Promise((resolve,reject)=>{if(db)return resolve(db);let open=indexedDB.open(dbName,1);open.onerror=(e=>{Fail(e,reject)}),open.onupgradeneeded=(e=>{(db=e.target.result).createObjectStore(dbName,{keyPath:"key"})}),open.onsuccess=(e=>{db=e.target.result,resolve(db)})}))();let tx=db.transaction([dbName],method);return tx.onerror=(e=>{Fail(e,reject)}),tx.objectStore(dbName)},list=query=>new Promise(async(resolve,reject)=>{let store=await txStore("readonly");query&&"object"==typeof query||(query={});let limit,results=[],gt=query.gt||"\0",lt=query.lt||"ï¿¿";query.limit&&(limit=parseInt(query.limit));let reverse="next";query.reverse&&(reverse="prev");let req=store.openCursor(IDBKeyRange.bound(gt,lt,!0,!0),reverse);req.onsuccess=(()=>{let cursor=req.result;if(!limit&&cursor||results.length<limit&&cursor){let result={};result=query.values?cursor.value:cursor.primaryKey,results.push(result),cursor.continue()}else resolve(results)}),req.onerror=req.onblocked=(err=>{reject({code:400,message:"Error deleting database. "+err.toString()})})});return{put:(key,value)=>new Promise(async(resolve,reject)=>{let req=(await txStore("readwrite")).put({key:key,value:value});req.onsuccess=(event=>{let e={event:"write",key:key,timestamp:Date.now()};eventHandler(e),resolve(e)}),req.onerror=req.onblocked=(err=>{Fail(e,reject)})}),get:key=>new Promise(async(resolve,reject)=>{let req=(await txStore("readonly")).get(key);req.onsuccess=(e=>{resolve(req.result||{key:key,value:null})}),req.onerror=req.onblocked=(err=>{Fail(e,reject)})}),del:(keys=[])=>new Promise(async(resolve,reject)=>{let store=await txStore("readwrite"),keyPaths=[];if(!keys)return reject({code:400,message:"A key or an array of keys is required."});let ops=[];(keyPaths="string"==typeof keys?[keys]:keys).forEach(path=>{ops.push({type:"del",key:path})});for(let i=0;i<keyPaths.length;i++)store.delete(keyPaths[i]);store.transaction.oncomplete=(()=>{let e={db:dbName,event:"delete",keys:keyPaths,timestamp:Date.now()};eventHandler(e),resolve(e)}),store.transaction.onerror=(err=>{db.close(),reject(err)})}),list:list,deleteDB:()=>new Promise(async(resolve,reject)=>{await close();let req=indexedDB.deleteDatabase(dbName);req.onsuccess=(()=>{let e={db:dbName,event:"deleteDB",timestamp:Date.now()};eventHandler(e),resolve(e)}),req.onerror=(err=>{reject({code:400,message:"Error deleting database. "+err.toString()})})}),exportDB:async()=>{return await list({values:!0})},importDB:(items=[])=>new Promise(async(resolve,reject)=>{let store=await txStore("readwrite");for(let x=0;x<items.length;x++)store.put(items[x]);store.transaction.oncomplete=(()=>{let e={db:dbName,event:"importDB",keys:items.map(val=>val.key),timestamp:Date.now()};eventHandler(e),resolve(e)}),store.onerror=(err=>{reject({code:400,message:"Error importing database. "+err.toString()})})}),onEvent:cb=>{onEvent=cb},close:close}}